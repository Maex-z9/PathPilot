---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/PathPilot.Core/Services/BuildTreeMapper.cs
  - src/PathPilot.Core/Models/SkillTree.cs
autonomous: true

must_haves:
  truths:
    - "Allocated node IDs from SkillTreeSet map to PassiveNode objects"
    - "Missing node IDs are logged as warnings (not crashes)"
    - "SkillTreeSet can provide enriched node details (keystones, notables lists)"
  artifacts:
    - path: "src/PathPilot.Core/Services/BuildTreeMapper.cs"
      provides: "Maps Build allocated nodes to parsed tree data"
      exports: ["GetAllocatedNodesAsync", "EnrichTreeSetAsync"]
  key_links:
    - from: "BuildTreeMapper"
      to: "SkillTreeDataService"
      via: "GetTreeDataAsync call"
      pattern: "_treeService\\.GetTreeDataAsync"
    - from: "BuildTreeMapper"
      to: "SkillTreeSet.AllocatedNodes"
      via: "Node ID iteration"
      pattern: "foreach.*AllocatedNodes"
---

<objective>
Create BuildTreeMapper service that connects imported build data (SkillTreeSet.AllocatedNodes) to the parsed GGG tree data (PassiveNode objects).

Purpose: Enables the UI to display detailed node information for allocated passives, completing the data pipeline from PoB import through to native rendering.

Output: BuildTreeMapper service that takes a SkillTreeSet and returns a list of PassiveNode objects with full details (name, stats, connections, classification).
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@src/PathPilot.Core/Models/SkillTree.cs
@src/PathPilot.Core/Models/build.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BuildTreeMapper Service</name>
  <files>src/PathPilot.Core/Services/BuildTreeMapper.cs</files>
  <action>
Create service that maps Build's allocated node IDs to full PassiveNode objects:

```csharp
using PathPilot.Core.Models;

namespace PathPilot.Core.Services;

/// <summary>
/// Maps build allocated nodes to parsed tree data
/// </summary>
public class BuildTreeMapper
{
    private readonly SkillTreeDataService _treeService;

    public BuildTreeMapper(SkillTreeDataService treeService)
    {
        _treeService = treeService;
    }

    /// <summary>
    /// Gets all allocated nodes as PassiveNode objects
    /// </summary>
    /// <param name="treeSet">The skill tree set from an imported build</param>
    /// <returns>List of PassiveNode with full details</returns>
    public async Task<List<PassiveNode>> GetAllocatedNodesAsync(SkillTreeSet treeSet)
    {
        var treeData = await _treeService.GetTreeDataAsync();
        if (treeData == null)
        {
            Console.WriteLine("Warning: Tree data not available, cannot map allocated nodes");
            return new List<PassiveNode>();
        }

        var allocatedNodes = new List<PassiveNode>();
        var missingCount = 0;

        foreach (var nodeId in treeSet.AllocatedNodes)
        {
            if (treeData.Nodes.TryGetValue(nodeId, out var node))
            {
                allocatedNodes.Add(node);
            }
            else
            {
                missingCount++;
                // Log first few missing IDs for debugging
                if (missingCount <= 5)
                {
                    Console.WriteLine($"Warning: Node {nodeId} not found in tree data");
                }
            }
        }

        if (missingCount > 5)
        {
            Console.WriteLine($"Warning: {missingCount} total nodes not found (possibly outdated build)");
        }

        return allocatedNodes;
    }

    /// <summary>
    /// Enriches a SkillTreeSet with node details from tree data
    /// </summary>
    /// <param name="treeSet">The skill tree set to enrich</param>
    public async Task EnrichTreeSetAsync(SkillTreeSet treeSet)
    {
        var nodes = await GetAllocatedNodesAsync(treeSet);

        // Populate keystone names
        treeSet.Keystones = nodes
            .Where(n => n.IsKeystone)
            .Select(n => n.Name)
            .Distinct()
            .ToList();

        // Populate notable names
        treeSet.Notables = nodes
            .Where(n => n.IsNotable)
            .Select(n => n.Name)
            .Distinct()
            .ToList();

        Console.WriteLine($"Enriched tree set: {treeSet.Keystones.Count} keystones, {treeSet.Notables.Count} notables");
    }

    /// <summary>
    /// Gets allocated nodes filtered by type
    /// </summary>
    public async Task<List<PassiveNode>> GetAllocatedByTypeAsync(SkillTreeSet treeSet, NodeType type)
    {
        var nodes = await GetAllocatedNodesAsync(treeSet);
        return nodes.Where(n => n.Type == type).ToList();
    }

    /// <summary>
    /// Gets allocated keystones
    /// </summary>
    public async Task<List<PassiveNode>> GetAllocatedKeystonesAsync(SkillTreeSet treeSet)
    {
        var nodes = await GetAllocatedNodesAsync(treeSet);
        return nodes.Where(n => n.IsKeystone).ToList();
    }

    /// <summary>
    /// Gets allocated notables
    /// </summary>
    public async Task<List<PassiveNode>> GetAllocatedNotablesAsync(SkillTreeSet treeSet)
    {
        var nodes = await GetAllocatedNodesAsync(treeSet);
        return nodes.Where(n => n.IsNotable).ToList();
    }

    /// <summary>
    /// Gets ascendancy nodes only
    /// </summary>
    public async Task<List<PassiveNode>> GetAllocatedAscendancyNodesAsync(SkillTreeSet treeSet)
    {
        var nodes = await GetAllocatedNodesAsync(treeSet);
        return nodes.Where(n => n.IsAscendancy).ToList();
    }
}
```

Key implementation points:
- Inject SkillTreeDataService via constructor (following existing service patterns)
- Log warnings for missing nodes but don't throw exceptions (graceful degradation)
- Provide helper methods for common filtering needs
- Use async/await throughout for consistency
  </action>
  <verify>
Run `dotnet build src/PathPilot.Core` - should compile without errors.
  </verify>
  <done>
BuildTreeMapper.cs exists with:
- Constructor taking SkillTreeDataService
- GetAllocatedNodesAsync method returning List<PassiveNode>
- EnrichTreeSetAsync method populating Keystones/Notables
- Helper methods for filtering by node type
- Warning logging for missing nodes
Project compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Position Calculation Helper</name>
  <files>src/PathPilot.Core/Models/SkillTree.cs</files>
  <action>
Extend PassiveNode with calculated position properties. Add to SkillTree.cs:

```csharp
// Add these properties to PassiveNode class after existing properties

/// <summary>
/// Group ID for position calculation
/// </summary>
public int? Group { get; set; }

/// <summary>
/// Orbit index within group (0-4)
/// </summary>
public int? Orbit { get; set; }

/// <summary>
/// Position index within orbit
/// </summary>
public int? OrbitIndex { get; set; }

/// <summary>
/// Ascendancy name if this is an ascendancy node
/// </summary>
public string? AscendancyName { get; set; }

/// <summary>
/// Calculated X position (set during rendering)
/// </summary>
public float? CalculatedX { get; set; }

/// <summary>
/// Calculated Y position (set during rendering)
/// </summary>
public float? CalculatedY { get; set; }
```

Also add a static helper class for position calculation (to be used in Phase 2):

```csharp
/// <summary>
/// Helper for calculating node positions from group/orbit data
/// </summary>
public static class SkillTreePositionHelper
{
    // Orbit radii from GGG data (pixels)
    private static readonly float[] OrbitRadii = { 0, 82, 162, 335, 493 };

    // Nodes per orbit
    private static readonly int[] NodesPerOrbit = { 1, 6, 12, 12, 40 };

    /// <summary>
    /// Calculates absolute position for a node given its group position
    /// </summary>
    public static (float X, float Y) CalculateNodePosition(
        PassiveNode node,
        float groupX,
        float groupY)
    {
        if (node.Orbit == null || node.OrbitIndex == null)
            return (groupX, groupY);

        var orbit = node.Orbit.Value;
        var orbitIndex = node.OrbitIndex.Value;

        if (orbit < 0 || orbit >= OrbitRadii.Length)
            return (groupX, groupY);

        var radius = OrbitRadii[orbit];
        var nodesInOrbit = NodesPerOrbit[orbit];

        // Calculate angle (radians, starting from top)
        var angle = (2 * Math.PI * orbitIndex / nodesInOrbit) - (Math.PI / 2);

        var x = groupX + (float)(radius * Math.Cos(angle));
        var y = groupY + (float)(radius * Math.Sin(angle));

        return (x, y);
    }

    /// <summary>
    /// Calculates positions for all nodes in tree data
    /// </summary>
    public static void CalculateAllPositions(SkillTreeData treeData)
    {
        foreach (var node in treeData.Nodes.Values)
        {
            if (node.Group == null) continue;

            if (treeData.Groups.TryGetValue(node.Group.Value, out var group))
            {
                var (x, y) = CalculateNodePosition(node, group.X, group.Y);
                node.CalculatedX = x;
                node.CalculatedY = y;
            }
        }
    }
}
```

Note: These position calculation methods will be used in Phase 2 (rendering).
  </action>
  <verify>
Run `dotnet build src/PathPilot.Core` - should compile without errors.
Check that PassiveNode has Group, Orbit, OrbitIndex, AscendancyName, CalculatedX, CalculatedY properties.
Check that SkillTreePositionHelper class exists with CalculateNodePosition and CalculateAllPositions methods.
  </verify>
  <done>
PassiveNode extended with position-related properties.
SkillTreePositionHelper created with position calculation methods.
All new code follows existing patterns in SkillTree.cs.
Project compiles successfully.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Build verification:
   ```bash
   cd /home/max/Documents/PathPilot
   dotnet build src/PathPilot.Core
   ```
   Expected: Build succeeded with 0 errors

2. API verification:
   - BuildTreeMapper has GetAllocatedNodesAsync(SkillTreeSet) method
   - BuildTreeMapper has EnrichTreeSetAsync(SkillTreeSet) method
   - PassiveNode has Group, Orbit, OrbitIndex properties
   - SkillTreePositionHelper has CalculateAllPositions method

3. Integration check:
   - BuildTreeMapper constructor accepts SkillTreeDataService
   - Position helper uses SkillTreeData with Groups
</verification>

<success_criteria>
1. BuildTreeMapper.cs created with node mapping logic
2. GetAllocatedNodesAsync returns PassiveNode list from SkillTreeSet
3. EnrichTreeSetAsync populates Keystones/Notables lists
4. Missing nodes logged as warnings (not errors)
5. PassiveNode extended with position-related properties
6. SkillTreePositionHelper ready for Phase 2 rendering
7. Project compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
