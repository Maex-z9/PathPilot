---
phase: 01-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/PathPilot.Core/Models/SkillTreeData.cs
  - src/PathPilot.Core/Services/SkillTreeDataService.cs
autonomous: true

must_haves:
  truths:
    - "App downloads GGG skill tree JSON on first request"
    - "Downloaded JSON is cached locally for 7 days"
    - "All ~3000 nodes are parsed with positions, names, connections"
    - "Groups are parsed for node position calculation"
  artifacts:
    - path: "src/PathPilot.Core/Models/SkillTreeData.cs"
      provides: "Container for parsed tree data (nodes dictionary, groups dictionary)"
      contains: "class SkillTreeData"
    - path: "src/PathPilot.Core/Services/SkillTreeDataService.cs"
      provides: "Tree data fetching, caching, and parsing"
      exports: ["GetTreeDataAsync", "GetNodeAsync"]
  key_links:
    - from: "SkillTreeDataService"
      to: "GGG GitHub raw JSON"
      via: "HttpClient.GetStreamAsync"
      pattern: "GetStreamAsync.*skilltree-export"
    - from: "SkillTreeDataService"
      to: "SkillTreeData"
      via: "JsonDocument parsing"
      pattern: "JsonDocument\\.ParseAsync"
---

<objective>
Create the core SkillTreeDataService that downloads, caches, and parses the official GGG Skill Tree JSON.

Purpose: Establishes the data foundation for native skill tree rendering by loading ~3000 nodes with their positions, connections, and metadata from GGG's official export.

Output: SkillTreeData model and SkillTreeDataService that can be called to get parsed tree data with automatic local caching.
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@src/PathPilot.Core/Models/SkillTree.cs
@src/PathPilot.Core/Services/GemDataService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SkillTreeData Model</name>
  <files>src/PathPilot.Core/Models/SkillTreeData.cs</files>
  <action>
Create a new model file that holds the parsed GGG skill tree data:

```csharp
namespace PathPilot.Core.Models;

/// <summary>
/// Container for parsed GGG Skill Tree data
/// </summary>
public class SkillTreeData
{
    /// <summary>
    /// All passive nodes keyed by node ID (integer key, not string)
    /// </summary>
    public Dictionary<int, PassiveNode> Nodes { get; set; } = new();

    /// <summary>
    /// Node groups for position calculation
    /// </summary>
    public Dictionary<int, NodeGroup> Groups { get; set; } = new();

    /// <summary>
    /// Tree version/league identifier
    /// </summary>
    public string Version { get; set; } = string.Empty;

    /// <summary>
    /// Total node count for validation
    /// </summary>
    public int TotalNodes => Nodes.Count;
}

/// <summary>
/// Represents a group of nodes (used for position calculation)
/// </summary>
public class NodeGroup
{
    public int Id { get; set; }
    public float X { get; set; }
    public float Y { get; set; }
    public List<int> NodeIds { get; set; } = new();
    public bool IsProxy { get; set; }
}
```

Also extend the existing PassiveNode class (in SkillTree.cs) with position fields if not present:
- Add `public int? Group { get; set; }` - group reference for position
- Add `public int? Orbit { get; set; }` - orbit index within group
- Add `public int? OrbitIndex { get; set; }` - position within orbit
- Add `public string? AscendancyName { get; set; }` - for ascendancy nodes

Follow existing naming patterns from SkillTree.cs.
  </action>
  <verify>
Run `dotnet build src/PathPilot.Core` - should compile without errors.
Verify file exists at expected path.
  </verify>
  <done>
SkillTreeData.cs exists with SkillTreeData and NodeGroup classes.
PassiveNode has Group, Orbit, OrbitIndex, and AscendancyName properties.
Project compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SkillTreeDataService</name>
  <files>src/PathPilot.Core/Services/SkillTreeDataService.cs</files>
  <action>
Create service following GemDataService pattern but with async/streaming for large JSON:

```csharp
using System.Text.Json;
using PathPilot.Core.Models;

namespace PathPilot.Core.Services;

/// <summary>
/// Service for loading and caching GGG Skill Tree data
/// </summary>
public class SkillTreeDataService
{
    private const string TREE_URL = "https://raw.githubusercontent.com/grindinggear/skilltree-export/master/data.json";
    private const int CACHE_DAYS = 7;

    private readonly HttpClient _httpClient;
    private readonly string _cacheDir;
    private readonly string _cachePath;

    private SkillTreeData? _treeData;
    private bool _isLoaded = false;

    public SkillTreeDataService()
    {
        _httpClient = new HttpClient();
        _httpClient.Timeout = TimeSpan.FromSeconds(60); // Large file

        _cacheDir = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "PathPilot", "tree-cache");
        _cachePath = Path.Combine(_cacheDir, "data.json");
    }

    /// <summary>
    /// Gets parsed tree data, downloading if needed
    /// </summary>
    public async Task<SkillTreeData?> GetTreeDataAsync()
    {
        if (_isLoaded && _treeData != null)
            return _treeData;

        try
        {
            var cachePath = await EnsureCacheAsync();
            _treeData = await ParseTreeDataAsync(cachePath);
            _isLoaded = true;
            Console.WriteLine($"Loaded skill tree: {_treeData.TotalNodes} nodes");
            return _treeData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading skill tree: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Gets a single node by ID
    /// </summary>
    public async Task<PassiveNode?> GetNodeAsync(int nodeId)
    {
        var data = await GetTreeDataAsync();
        return data?.Nodes.TryGetValue(nodeId, out var node) == true ? node : null;
    }

    private async Task<string> EnsureCacheAsync()
    {
        Directory.CreateDirectory(_cacheDir);

        // Check cache freshness
        if (File.Exists(_cachePath))
        {
            var age = DateTime.Now - File.GetLastWriteTime(_cachePath);
            if (age < TimeSpan.FromDays(CACHE_DAYS))
            {
                Console.WriteLine("Using cached skill tree data");
                return _cachePath;
            }
        }

        // Download fresh
        Console.WriteLine("Downloading skill tree data from GGG...");
        await using var stream = await _httpClient.GetStreamAsync(TREE_URL);
        await using var fileStream = File.Create(_cachePath);
        await stream.CopyToAsync(fileStream);
        Console.WriteLine("Skill tree data cached");

        return _cachePath;
    }

    private async Task<SkillTreeData> ParseTreeDataAsync(string filePath)
    {
        var treeData = new SkillTreeData();

        await using var stream = File.OpenRead(filePath);
        using var doc = await JsonDocument.ParseAsync(stream, new JsonDocumentOptions
        {
            AllowTrailingCommas = true,
            CommentHandling = JsonCommentHandling.Skip
        });

        var root = doc.RootElement;

        // Parse nodes
        if (root.TryGetProperty("nodes", out var nodesElement))
        {
            foreach (var nodeProp in nodesElement.EnumerateObject())
            {
                if (int.TryParse(nodeProp.Name, out var nodeId))
                {
                    var node = ParseNode(nodeId, nodeProp.Value);
                    treeData.Nodes[nodeId] = node;
                }
            }
        }

        // Parse groups
        if (root.TryGetProperty("groups", out var groupsElement))
        {
            foreach (var groupProp in groupsElement.EnumerateObject())
            {
                if (int.TryParse(groupProp.Name, out var groupId))
                {
                    var group = ParseGroup(groupId, groupProp.Value);
                    treeData.Groups[groupId] = group;
                }
            }
        }

        return treeData;
    }

    private PassiveNode ParseNode(int id, JsonElement element)
    {
        var node = new PassiveNode { Id = id };

        if (element.TryGetProperty("name", out var name))
            node.Name = name.GetString() ?? "";

        if (element.TryGetProperty("stats", out var stats))
        {
            node.Stats = stats.EnumerateArray()
                .Select(s => s.GetString() ?? "")
                .Where(s => !string.IsNullOrEmpty(s))
                .ToList();
        }

        // Connection handling - GGG JSON has string array
        if (element.TryGetProperty("out", out var outNodes))
        {
            node.ConnectedNodes = outNodes.EnumerateArray()
                .Select(n => n.ValueKind == JsonValueKind.Number
                    ? n.GetInt32()
                    : int.TryParse(n.GetString(), out var parsed) ? parsed : 0)
                .Where(n => n != 0)
                .ToList();
        }

        // Node classification
        node.IsKeystone = element.TryGetProperty("isKeystone", out var ks) && ks.GetBoolean();
        node.IsNotable = element.TryGetProperty("isNotable", out var nt) && nt.GetBoolean();
        node.IsJewelSocket = element.TryGetProperty("isJewelSocket", out var js) && js.GetBoolean();
        node.IsMastery = element.TryGetProperty("isMastery", out var ms) && ms.GetBoolean();

        // Position data
        if (element.TryGetProperty("group", out var group))
            node.Group = group.GetInt32();
        if (element.TryGetProperty("orbit", out var orbit))
            node.Orbit = orbit.GetInt32();
        if (element.TryGetProperty("orbitIndex", out var orbitIndex))
            node.OrbitIndex = orbitIndex.GetInt32();

        // Ascendancy
        if (element.TryGetProperty("ascendancyName", out var ascName))
        {
            node.AscendancyName = ascName.GetString();
            node.IsAscendancy = true;
        }

        return node;
    }

    private NodeGroup ParseGroup(int id, JsonElement element)
    {
        var group = new NodeGroup { Id = id };

        if (element.TryGetProperty("x", out var x))
            group.X = x.GetSingle();
        if (element.TryGetProperty("y", out var y))
            group.Y = y.GetSingle();
        if (element.TryGetProperty("isProxy", out var isProxy))
            group.IsProxy = isProxy.GetBoolean();

        if (element.TryGetProperty("nodes", out var nodes))
        {
            group.NodeIds = nodes.EnumerateArray()
                .Select(n => n.ValueKind == JsonValueKind.Number
                    ? n.GetInt32()
                    : int.TryParse(n.GetString(), out var parsed) ? parsed : 0)
                .Where(n => n != 0)
                .ToList();
        }

        return group;
    }
}
```

Key implementation points:
- Use streaming with JsonDocument.ParseAsync (avoids LOH allocation)
- Local file cache with 7-day expiry
- Parse string keys to int (GGG JSON quirk)
- Handle both number and string node IDs in arrays
- Follow GemDataService lazy-loading pattern (_isLoaded flag)
  </action>
  <verify>
Run `dotnet build src/PathPilot.Core` - should compile without errors.
Verify no warnings about null references or unused variables.
  </verify>
  <done>
SkillTreeDataService.cs exists with:
- GetTreeDataAsync() method that returns parsed SkillTreeData
- GetNodeAsync() method for single node lookup
- Local cache at ~/.config/PathPilot/tree-cache/data.json
- 7-day cache expiry
- Streaming JSON parse using JsonDocument
Project compiles successfully.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Build verification:
   ```bash
   cd /home/max/Documents/PathPilot
   dotnet build src/PathPilot.Core
   ```
   Expected: Build succeeded with 0 errors

2. File existence check:
   ```bash
   ls -la src/PathPilot.Core/Models/SkillTreeData.cs
   ls -la src/PathPilot.Core/Services/SkillTreeDataService.cs
   ```
   Expected: Both files exist

3. Code pattern verification:
   - SkillTreeData contains Dictionary<int, PassiveNode> Nodes
   - SkillTreeDataService has async GetTreeDataAsync method
   - Service uses JsonDocument.ParseAsync for streaming
</verification>

<success_criteria>
1. SkillTreeData.cs created with SkillTreeData and NodeGroup models
2. PassiveNode extended with Group, Orbit, OrbitIndex, AscendancyName properties
3. SkillTreeDataService.cs created with async data loading
4. Service downloads from GGG GitHub and caches locally
5. Service parses all nodes and groups from JSON
6. Project compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
