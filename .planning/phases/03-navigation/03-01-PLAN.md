---
phase: 03-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
  - src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
autonomous: false

must_haves:
  truths:
    - "User can zoom in with mouse wheel scroll up"
    - "User can zoom out with mouse wheel scroll down"
    - "Zoom centers on mouse cursor position (content under cursor stays under cursor)"
    - "User can drag to pan the view with left mouse button"
    - "Pan speed feels consistent regardless of zoom level"
    - "Tree view starts centered on allocated nodes when window opens"
    - "Tree view starts centered on start point if no allocated nodes"
  artifacts:
    - path: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      provides: "Zoom/pan navigation with pointer events"
      contains: "OnPointerWheelChanged"
    - path: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      provides: "Coordinate transformation functions"
      contains: "ScreenToWorld"
    - path: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      provides: "Initial centering logic"
      contains: "CenterOnAllocatedNodes"
  key_links:
    - from: "SkillTreeCanvas.OnPointerWheelChanged"
      to: "SkillTreeCanvas.InvalidateVisual"
      via: "zoom update triggers redraw"
      pattern: "InvalidateVisual\\(\\)"
    - from: "SkillTreeCanvas.OnPointerMoved"
      to: "offset fields (_offsetX, _offsetY)"
      via: "pan delta updates offset"
      pattern: "_offsetX.*-=|_offsetY.*-="
    - from: "TreeViewerWindow loaded event"
      to: "SkillTreeCanvas.CenterOnAllocatedNodes"
      via: "initial centering on window open"
      pattern: "CenterOnAllocatedNodes"
---

<objective>
Implement zoom and pan navigation for the skill tree viewer, allowing users to navigate the ~1300 node tree naturally with mouse wheel zoom and drag-based panning.

Purpose: Without navigation, users cannot explore the full skill tree - they see only a portion at fixed zoom. This phase makes the tree viewer actually usable for build planning.

Output: SkillTreeCanvas with full zoom/pan controls, automatic centering on allocated nodes
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-navigation/03-RESEARCH.md

# Source files to modify
@src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
@src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement zoom and pan controls in SkillTreeCanvas</name>
  <files>src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs, src/PathPilot.Desktop/TreeViewerWindow.axaml.cs</files>
  <action>
Add zoom and pan navigation to SkillTreeCanvas by implementing Avalonia pointer event overrides. This replaces the existing button-based zoom that uses Canvas.Width/Height scaling.

**FIRST: Remove existing conflicting zoom implementation in TreeViewerWindow.axaml.cs:**
1. Remove the `ApplyZoom()` method lines that scale Canvas dimensions:
   - DELETE: `TreeCanvas.Width = baseWidth * _zoomLevel;`
   - DELETE: `TreeCanvas.Height = baseHeight * _zoomLevel;`
2. Keep `TreeCanvas.ZoomLevel = _zoomLevel;` and `ZoomLevelText.Text = ...` for display
3. Wire ZoomInButton_Click and ZoomOutButton_Click to call new SkillTreeCanvas methods instead:
   - Add `public void ZoomIn()` and `public void ZoomOut()` methods to SkillTreeCanvas
   - Button handlers call `TreeCanvas.ZoomIn()` and `TreeCanvas.ZoomOut()`
4. Keep the _zoomLevel field in TreeViewerWindow only for initial value, then let SkillTreeCanvas own the state

**Why this matters:** The current implementation scales Canvas.Width/Height (lines 149-150 in TreeViewerWindow.axaml.cs). The new approach uses SkiaSharp `canvas.Scale()` in the render operation. Having both would cause double-scaling. SkiaSharp canvas.Scale() must be the SINGLE zoom mechanism.

**State fields to add in SkillTreeCanvas:**
- `_offsetX`, `_offsetY` (float) - Pan offset in world coordinates
- `_isPanning` (bool) - Whether drag is in progress
- `_lastPointerPos` (Point) - Last pointer position for delta calculation
- `_pointerCaptured` (bool) - Track pointer capture state

**Constants in SkillTreeCanvas:**
- `MinZoom = 0.02f` - Minimum zoom (can see entire tree)
- `MaxZoom = 2.0f` - Maximum zoom (200%)

**Implement zoom (OnPointerWheelChanged override):**
1. Get pointer position with `e.GetCurrentPoint(this).Position`
2. Convert to world coords BEFORE zoom with ScreenToWorld()
3. Calculate zoom factor: `delta > 0 ? 1.1f : 0.9f`
4. Update ZoomLevel with Math.Clamp to MinZoom/MaxZoom
5. Convert same pointer position to world coords AFTER zoom
6. Correct offset: `_offsetX += (worldBefore.X - worldAfter.X)`
7. Call InvalidateVisual()

**Implement ZoomIn() and ZoomOut() public methods:**
- ZoomIn: Multiply ZoomLevel by 1.15f, clamp, recalculate offset to center zoom, InvalidateVisual()
- ZoomOut: Multiply ZoomLevel by 0.85f, clamp, recalculate offset to center zoom, InvalidateVisual()

**Implement pan (OnPointerPressed/Moved/Released overrides):**
- OnPointerPressed: If left button, set `_isPanning = true`, capture pointer with `e.Pointer.Capture(this)`, store position
- OnPointerMoved: If panning, calculate delta, update offsets (divide delta by ZoomLevel for consistent feel), store position, InvalidateVisual()
- OnPointerReleased: Set `_isPanning = false`, release capture with `e.Pointer.Capture(null)`
- OnPointerCaptureLost: Safety cleanup of panning state

**Coordinate transformation helpers:**
```csharp
private SKPoint ScreenToWorld(Point screenPos)
{
    return new SKPoint(
        (float)(screenPos.X / ZoomLevel + _offsetX),
        (float)(screenPos.Y / ZoomLevel + _offsetY));
}
```

**Update SkillTreeDrawOperation:**
- Add `_offsetX`, `_offsetY` parameters to constructor
- In Render(), apply transformation: `canvas.Translate(-_offsetX * _zoomLevel, -_offsetY * _zoomLevel)` before `canvas.Scale()`

**Important:** Transformation order matters - Translate first (for offset), then Scale (for zoom).
  </action>
  <verify>
Build succeeds: `dotnet build src/PathPilot.Desktop/PathPilot.Desktop.csproj`
  </verify>
  <done>
SkillTreeCanvas has OnPointerWheelChanged, OnPointerPressed, OnPointerMoved, OnPointerReleased overrides. SkillTreeDrawOperation applies offset transformation. TreeViewerWindow no longer scales Canvas.Width/Height. Zoom buttons call SkillTreeCanvas.ZoomIn()/ZoomOut(). SkiaSharp canvas.Scale() is the single zoom mechanism.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement initial centering and wire to TreeViewerWindow</name>
  <files>src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs, src/PathPilot.Desktop/TreeViewerWindow.axaml.cs</files>
  <action>
**In SkillTreeCanvas, add CenterOnAllocatedNodes() method:**
1. Check if AllocatedNodeIds is null/empty or TreeData is null -> call CenterOnStartNode()
2. Calculate bounding box of allocated nodes:
   - Iterate allocated node IDs
   - Get node from TreeData.Nodes dictionary
   - Track minX, maxX, minY, maxY from CalculatedX/CalculatedY
3. If no valid nodes found -> call CenterOnStartNode()
4. Calculate center: `centerX = (minX + maxX) / 2`, `centerY = (minY + maxY) / 2`
5. Set initial zoom to fit allocated nodes (optional: use fixed zoom like 0.08f)
6. Set offset to center this point in viewport:
   ```csharp
   _offsetX = centerX - (float)(Bounds.Width / 2 / ZoomLevel);
   _offsetY = centerY - (float)(Bounds.Height / 2 / ZoomLevel);
   ```
7. Call InvalidateVisual()

**Add CenterOnStartNode() fallback method:**
- Center on tree origin (approximately 14000, 11000 after GGG offset applied)
- Use same offset formula with tree center coordinates

**Make CenterOnAllocatedNodes() public** so TreeViewerWindow can call it.

**In TreeViewerWindow.axaml.cs:**
- After setting TreeCanvas.TreeData and TreeCanvas.AllocatedNodeIds, call `TreeCanvas.CenterOnAllocatedNodes()`
- This should happen in the existing data loading flow (after tree positions are calculated)

**Handle Bounds timing:** CenterOnAllocatedNodes needs valid Bounds. Either:
- Call in OnLoaded event handler, OR
- Check `Bounds.Width > 0` and skip if not ready yet, then call from SizeChanged or AttachedToVisualTree
  </action>
  <verify>
Build succeeds: `dotnet build src/PathPilot.Desktop/PathPilot.Desktop.csproj`
  </verify>
  <done>
SkillTreeCanvas has public CenterOnAllocatedNodes() method. TreeViewerWindow calls it after loading tree data. Initial view centers on allocated nodes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify zoom and pan navigation</name>
  <what-built>
Complete zoom/pan navigation for skill tree viewer:
- Mouse wheel zoom (centered on cursor)
- Left-click drag to pan
- Initial centering on allocated nodes
  </what-built>
  <how-to-verify>
1. Run the application: `dotnet run --project src/PathPilot.Desktop/PathPilot.Desktop.csproj`
2. Load a build with allocated skill tree nodes (import from pobb.in or load saved build)
3. Click "Show Skill Tree" button to open TreeViewerWindow
4. **Check initial centering:** Tree should be centered on the allocated (gold) nodes, not the origin
5. **Check zoom-in:** Scroll mouse wheel UP - tree should zoom in, with content under cursor staying under cursor
6. **Check zoom-out:** Scroll mouse wheel DOWN - tree should zoom out, with content under cursor staying under cursor
7. **Check pan:** Click and drag with left mouse button - tree should pan smoothly following the mouse
8. **Check pan speed:** Pan at different zoom levels - speed should feel consistent (not faster when zoomed out)
9. **Check zoom limits:** Try zooming very far in and out - should stop at reasonable limits (can see entire tree when zoomed out, individual nodes when zoomed in)

Expected behavior:
- Gold (allocated) nodes visible and centered on window open
- Smooth, responsive zoom and pan
- No content jumping or jittering
- Consistent navigation feel at all zoom levels
  </how-to-verify>
  <resume-signal>Type "approved" if navigation works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- `dotnet build src/PathPilot.Desktop/PathPilot.Desktop.csproj` compiles without errors
- Application launches and TreeViewerWindow opens
- Zoom in/out with mouse wheel works
- Pan with left mouse drag works
- Initial view centers on allocated nodes
</verification>

<success_criteria>
1. NAV-01 satisfied: User can zoom in/out using mouse wheel
2. NAV-02 satisfied: User can drag to pan the view
3. NAV-03 satisfied: Tree starts centered on allocated nodes (or start point if none)
4. Zoom is centered on mouse cursor position
5. Pan speed is consistent regardless of zoom level
</success_criteria>

<output>
After completion, create `.planning/phases/03-navigation/03-01-SUMMARY.md`
</output>
