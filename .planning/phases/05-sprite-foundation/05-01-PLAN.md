---
phase: 05-sprite-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/PathPilot.Core/Models/SpriteSheet.cs
  - src/PathPilot.Core/Models/SkillTreeData.cs
  - src/PathPilot.Core/Models/SkillTree.cs
  - src/PathPilot.Core/Services/SkillTreeDataService.cs
  - src/PathPilot.Core/Services/SkillTreeSpriteService.cs
autonomous: true

must_haves:
  truths:
    - "Sprite coordinate data is parsed from the GGG JSON (sprites section)"
    - "Every node has an Icon property matching sprite sheet coord keys"
    - "Groups with backgrounds have parsed Background property (image + isHalfImage)"
    - "Sprite sheets download from poecdn.com and cache to ~/.config/PathPilot/tree-sprites/"
    - "SKBitmaps are held in memory by the service and never disposed by consumers"
  artifacts:
    - path: "src/PathPilot.Core/Models/SpriteSheet.cs"
      provides: "SpriteSheet and SpriteCoordinate data models"
      contains: "class SpriteSheet"
    - path: "src/PathPilot.Core/Models/SkillTreeData.cs"
      provides: "Extended SkillTreeData with SpriteSheets dictionary and GroupBackground model"
      contains: "SpriteSheets"
    - path: "src/PathPilot.Core/Models/SkillTree.cs"
      provides: "PassiveNode.Icon and NodeGroup.Background properties"
      contains: "Icon"
    - path: "src/PathPilot.Core/Services/SkillTreeDataService.cs"
      provides: "Parsing of sprites, node icon, and group background from JSON"
      contains: "skillSprites"
    - path: "src/PathPilot.Core/Services/SkillTreeSpriteService.cs"
      provides: "Sprite sheet download, disk cache, in-memory SKBitmap cache"
      contains: "class SkillTreeSpriteService"
  key_links:
    - from: "src/PathPilot.Core/Services/SkillTreeDataService.cs"
      to: "src/PathPilot.Core/Models/SpriteSheet.cs"
      via: "Populates SpriteSheet objects from JSON"
      pattern: "SpriteSheet"
    - from: "src/PathPilot.Core/Services/SkillTreeSpriteService.cs"
      to: "src/PathPilot.Core/Models/SpriteSheet.cs"
      via: "Uses SpriteSheet.Filename to download correct sprite sheet"
      pattern: "Filename"
    - from: "src/PathPilot.Core/Services/SkillTreeSpriteService.cs"
      to: "web.poecdn.com"
      via: "HTTP GET to download sprite sheet PNGs/JPGs"
      pattern: "GetAsync"
---

<objective>
Create the data layer for sprite rendering: models for sprite sheet coordinates, enhanced JSON parsing to extract sprite/icon/background data, and a sprite sheet download+cache service.

Purpose: All rendering (Plan 02) depends on having parsed sprite metadata and downloaded sprite sheet bitmaps available in memory.
Output: SpriteSheet model, enhanced SkillTreeDataService, SkillTreeSpriteService
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-sprite-foundation/05-RESEARCH.md
@src/PathPilot.Core/Models/SkillTreeData.cs
@src/PathPilot.Core/Models/SkillTree.cs
@src/PathPilot.Core/Services/SkillTreeDataService.cs
@src/PathPilot.Core/Services/GemIconService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sprite data models and JSON parsing</name>
  <files>
    src/PathPilot.Core/Models/SpriteSheet.cs
    src/PathPilot.Core/Models/SkillTreeData.cs
    src/PathPilot.Core/Models/SkillTree.cs
    src/PathPilot.Core/Services/SkillTreeDataService.cs
  </files>
  <action>
    **1. Create `SpriteSheet.cs` model** with these classes:

    ```csharp
    public class SpriteCoordinate
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int W { get; set; }
        public int H { get; set; }
    }

    public class SpriteSheetData
    {
        public string Filename { get; set; } = string.Empty;  // Full URL from JSON
        public int SheetWidth { get; set; }   // "w" from JSON
        public int SheetHeight { get; set; }  // "h" from JSON
        public Dictionary<string, SpriteCoordinate> Coords { get; set; } = new();
    }
    ```

    **2. Add `GroupBackground` model** (can be in SpriteSheet.cs or SkillTreeData.cs):
    ```csharp
    public class GroupBackground
    {
        public string Image { get; set; } = string.Empty;  // e.g. "PSGroupBackground3"
        public bool IsHalfImage { get; set; }
    }
    ```

    **3. Extend `SkillTreeData.cs`**: Add a property to hold parsed sprite data organized for fast lookup:
    ```csharp
    // Key: sprite type (e.g. "normalActive"), Value: dict keyed by zoom string (e.g. "0.1246")
    public Dictionary<string, Dictionary<string, SpriteSheetData>> SpriteSheets { get; set; } = new();
    // Parsed imageZoomLevels from JSON
    public List<float> ImageZoomLevels { get; set; } = new();
    ```

    **4. Extend `PassiveNode` in SkillTree.cs**: Add `public string? Icon { get; set; }` property. This stores the sprite coord key like `"Art/2DArt/SkillIcons/passives/2handeddamage.png"`.

    **5. Extend `NodeGroup` in SkillTreeData.cs**: Add `public GroupBackground? Background { get; set; }` property.

    **6. Enhance `SkillTreeDataService.ParseTreeDataAsync()`**: After existing node/group parsing, add three new parsing sections:

    a) **Parse `imageZoomLevels`** array: `treeData.ImageZoomLevels = [0.1246f, 0.2109f, 0.2972f, 0.3835f]` from JSON.

    b) **Parse `sprites` section** (IMPORTANT: the JSON key is `"sprites"`, NOT `"skillSprites"`). Structure is:
    ```
    sprites -> {type} -> {zoomKey} -> { filename, w, h, coords: { iconKey: {x,y,w,h} } }
    ```
    Parse these sprite types (needed for Phase 5): `normalActive`, `normalInactive`, `notableActive`, `notableInactive`, `keystoneActive`, `keystoneInactive`, `frame`, `jewel`, `groupBackground`.
    For each type+zoomKey, create a `SpriteSheetData` with filename, w, h, and all coords.
    Store in `treeData.SpriteSheets[type][zoomKey] = spriteSheetData`.

    c) **Parse `icon` property** on each node in `ParseNode()`:
    ```csharp
    if (element.TryGetProperty("icon", out var icon))
        node.Icon = icon.GetString();
    ```

    d) **Parse `background` property** on each group in `ParseGroup()`:
    ```csharp
    if (element.TryGetProperty("background", out var bgElement))
    {
        group.Background = new GroupBackground
        {
            Image = bgElement.GetProperty("image").GetString() ?? "",
            IsHalfImage = bgElement.TryGetProperty("isHalfImage", out var half) && half.GetBoolean()
        };
    }
    ```

    IMPORTANT DETAILS from actual JSON inspection:
    - Active sprites (normalActive, notableActive, keystoneActive) share the SAME sprite sheet file (e.g. `skills-0.jpg`). The coords differ per type though.
    - Inactive sprites share `skills-disabled-N.jpg`.
    - Frame, jewel, groupBackground each have their own files.
    - Sprite coord keys look like `"Art/2DArt/SkillIcons/passives/2handeddamage.png"` (matching node.Icon).
    - Frame coord keys look like `"KeystoneFrameUnallocated"`, `"NotableFrameUnallocated"` etc.
    - GroupBackground coord keys look like `"PSGroupBackground3"`, `"PSGroupBackground2"`, `"PSGroupBackground1"`.
  </action>
  <verify>
    `dotnet build src/PathPilot.Core/PathPilot.Core.csproj` compiles without errors.
    Add a temporary Console.WriteLine in ParseTreeDataAsync after sprite parsing to confirm:
    - SpriteSheets dictionary has 9+ type entries
    - Each type has 3-4 zoom entries
    - normalActive["0.3835"] has 385 coords
    - Nodes with Icon property: ~3135
    - Groups with Background: ~440
    Run `dotnet run --project src/PathPilot.Desktop/PathPilot.Desktop.csproj` and check console output.
  </verify>
  <done>
    SpriteSheet/SpriteCoordinate/GroupBackground models exist. PassiveNode has Icon property. NodeGroup has Background property. SkillTreeDataService parses sprites section, node icons, and group backgrounds from JSON. Build compiles. Console output confirms correct counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sprite sheet download and cache service</name>
  <files>
    src/PathPilot.Core/Services/SkillTreeSpriteService.cs
  </files>
  <action>
    Create `SkillTreeSpriteService.cs` following the GemIconService pattern (same file for reference). This service:

    1. **Constructor**: Creates HttpClient (timeout 30s, UserAgent "PathPilot/1.0"), sets cache dir to `~/.config/PathPilot/tree-sprites/`, creates directory.

    2. **In-memory cache**: `Dictionary<string, SKBitmap> _loadedBitmaps` keyed by filename (the URL path, not full URL). Service OWNS these bitmaps -- consumers must NEVER dispose them.

    3. **Download deduplication**: `ConcurrentDictionary<string, Task<SKBitmap?>> _downloadTasks` to prevent parallel downloads of the same file (identical pattern to GemIconService).

    4. **Core method `GetSpriteSheetAsync(string fullUrl)`**:
       - Extract filename from URL for cache key: take everything after last `/`, strip query string. E.g. `https://web.poecdn.com/image/passive-skill/skills-0.jpg?511ee3db` -> `skills-0.jpg`
       - Check `_loadedBitmaps` first (fast path, no I/O)
       - Check disk cache: `~/.config/PathPilot/tree-sprites/{filename}`, if exists and < 30 days old, load via `SKBitmap.Decode(stream)`, store in `_loadedBitmaps`, return
       - Download from full URL, save to disk cache, decode to SKBitmap, store in `_loadedBitmaps`, return
       - On any error, return null (graceful degradation)
       - Use ConcurrentDictionary.GetOrAdd for deduplication

    5. **Preload method `PreloadSpriteSheetsAsync(SkillTreeData treeData, string zoomKey)`**:
       - Takes parsed tree data and a zoom level key (e.g. "0.3835")
       - Collects all unique sprite sheet URLs for that zoom level from treeData.SpriteSheets
       - Downloads all in parallel using `Task.WhenAll`
       - Logs count of loaded sheets to console
       - This allows TreeViewerWindow to preload sprites during initialization

    6. **IDisposable**: Dispose HttpClient and all SKBitmaps in `_loadedBitmaps`.

    IMPORTANT: This service needs a SkiaSharp reference. It lives in PathPilot.Core but needs `SkiaSharp` NuGet. Check if PathPilot.Core.csproj already references SkiaSharp. If not, add the package reference. Alternatively, place the service in PathPilot.Desktop if that's where SkiaSharp is referenced -- but the GemIconService pattern keeps services in Core.

    If SkiaSharp is NOT in Core: Add `<PackageReference Include="SkiaSharp" Version="2.88.*" />` to PathPilot.Core.csproj. This is acceptable because the service needs SKBitmap for decoding.
  </action>
  <verify>
    `dotnet build src/PathPilot.Core/PathPilot.Core.csproj` compiles. Verify SKBitmap resolves (SkiaSharp package present).
    `dotnet build src/PathPilot.Desktop/PathPilot.Desktop.csproj` compiles.
  </verify>
  <done>
    SkillTreeSpriteService exists with GetSpriteSheetAsync (disk cache + memory cache + download) and PreloadSpriteSheetsAsync. Service follows GemIconService pattern. Implements IDisposable. Build compiles.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds for both Core and Desktop projects
2. Run app, open tree viewer -- console shows sprite parsing counts (types, zoom levels, coords)
3. No runtime errors from new parsing code (existing functionality unchanged)
</verification>

<success_criteria>
- SpriteSheet, SpriteCoordinate, GroupBackground models exist with correct properties
- PassiveNode has Icon property populated from JSON for ~3135 nodes
- NodeGroup has Background property populated for ~440 groups
- SkillTreeDataService parses sprites section with 9+ types, 3-4 zoom levels each
- SkillTreeSpriteService can download, cache to disk, and hold SKBitmaps in memory
- All existing functionality unchanged (tree viewer still works with colored dots)
</success_criteria>

<output>
After completion, create `.planning/phases/05-sprite-foundation/05-01-SUMMARY.md`
</output>
