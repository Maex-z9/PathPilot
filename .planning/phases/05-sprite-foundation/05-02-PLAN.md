---
phase: 05-sprite-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
  - src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
autonomous: false

must_haves:
  truths:
    - "User sees real PoE node sprites instead of colored dots"
    - "Allocated nodes show active sprites, unallocated show inactive sprites"
    - "Group background images render behind node clusters"
    - "Sprite quality automatically changes based on zoom level (4 GGG thresholds)"
    - "App falls back to colored dots if sprites fail to load"
  artifacts:
    - path: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      provides: "Sprite-based node rendering with LOD and group backgrounds"
      contains: "DrawBitmap"
    - path: "src/PathPilot.Desktop/TreeViewerWindow.axaml.cs"
      provides: "Sprite service initialization and preloading"
      contains: "SkillTreeSpriteService"
  key_links:
    - from: "src/PathPilot.Desktop/TreeViewerWindow.axaml.cs"
      to: "src/PathPilot.Core/Services/SkillTreeSpriteService.cs"
      via: "Creates service instance, calls PreloadSpriteSheetsAsync, passes to canvas"
      pattern: "PreloadSpriteSheetsAsync"
    - from: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      to: "src/PathPilot.Core/Services/SkillTreeSpriteService.cs"
      via: "Canvas receives loaded SKBitmaps from service for rendering"
      pattern: "GetSpriteSheetAsync"
    - from: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      to: "src/PathPilot.Core/Models/SpriteSheet.cs"
      via: "Uses SpriteCoordinate for source rects in DrawBitmap"
      pattern: "SpriteCoordinate"
---

<objective>
Replace colored dot rendering with authentic PoE sprites in SkillTreeCanvas. Add group background rendering, zoom-based LOD switching, and active/inactive sprite selection.

Purpose: This is the visual payoff -- users see real PoE node sprites instead of colored circles, making the tree viewer look professional and matching GGG's website quality.
Output: Fully sprite-rendered skill tree with group backgrounds and LOD
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-sprite-foundation/05-RESEARCH.md
@.planning/phases/05-sprite-foundation/05-01-SUMMARY.md
@src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
@src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
@src/PathPilot.Core/Models/SkillTreeData.cs
@src/PathPilot.Core/Models/SpriteSheet.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sprite-based node rendering with LOD and group backgrounds</name>
  <files>
    src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
    src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
  </files>
  <action>
    **A. Wire sprite service into TreeViewerWindow.axaml.cs:**

    1. Add `SkillTreeSpriteService` field (created in constructor, disposed when window closes).
    2. In `LoadTreeAsync()`, after tree data is loaded and positions calculated, determine initial zoom key and call `PreloadSpriteSheetsAsync(treeData, zoomKey)`.
    3. Pass the sprite service and tree data to the canvas. Add a new property or method on SkillTreeCanvas to accept the sprite service reference. Options:
       - Add `StyledProperty<SkillTreeSpriteService?>` on canvas (simplest)
       - Or pass loaded bitmaps as a dictionary
       Prefer: Add a method `SetSpriteData(SkillTreeSpriteService service)` or a property. The canvas needs the service to look up sprite sheets by type+zoom.

    **B. Add LOD zoom level selection to SkillTreeCanvas:**

    Add a helper method that maps the current zoom level to the nearest GGG sprite quality:
    ```csharp
    // GGG zoom thresholds: 0.1246, 0.2109, 0.2972, 0.3835
    // Midpoints for switching: 0.1728, 0.2540, 0.3403
    private static string GetSpriteZoomKey(float currentZoom)
    {
        if (currentZoom < 0.1728f) return "0.1246";
        if (currentZoom < 0.2540f) return "0.2109";
        if (currentZoom < 0.3403f) return "0.2972";
        return "0.3835";
    }
    ```

    Track the current sprite zoom key. When zoom changes and crosses a threshold, trigger preload of the new zoom level's sprite sheets (async, non-blocking -- canvas continues rendering with current sprites until new ones are loaded).

    **C. Modify SkillTreeDrawOperation to accept sprite data:**

    The `SkillTreeDrawOperation` inner class needs access to:
    - Loaded SKBitmaps for the current zoom level (keyed by sprite type like "normalActive")
    - SpriteSheetData for coordinate lookups (keyed by sprite type + zoom key)
    - The SkillTreeData (already has this)

    Add constructor parameters for a `Dictionary<string, SKBitmap>` (loaded sheets) and `Dictionary<string, SpriteSheetData>` (coord maps). Build these dictionaries before creating the draw operation.

    **D. Replace DrawNodes with sprite rendering:**

    In `DrawNodes()`, replace the circle drawing with sprite-based rendering:

    1. For each node with a position, determine the sprite type based on node type + allocation:
       - Normal node, allocated -> "normalActive"
       - Normal node, unallocated -> "normalInactive"
       - Notable, allocated -> "notableActive"
       - Notable, unallocated -> "notableInactive"
       - Keystone, allocated -> "keystoneActive"
       - Keystone, unallocated -> "keystoneInactive"
       - JewelSocket -> "jewel" (use "JewelSocketActiveBlue" for allocated, "JewelSocketNormal" for unallocated -- check actual coord keys in jewel sprite sheet)
       - Mastery -> skip sprites for now, keep colored circle (mastery sprites are a separate concern)

    2. Look up the node's `Icon` property in the sprite sheet's Coords dictionary.
    3. If found, extract source rect `SKRect(coord.X, coord.Y, coord.X + coord.W, coord.Y + coord.H)`.
    4. Calculate destination rect centered on node position. The sprite dest size should match the coord W/H values (they are already scaled per zoom level by GGG).
    5. Draw using `canvas.DrawBitmap(spriteSheet, srcRect, destRect)`. Do NOT use `SKImage.FromBitmap()` in the render loop (memory leak).
    6. If sprite lookup fails (no bitmap, no icon, no coord match), FALLBACK to the existing colored circle rendering. This ensures graceful degradation.

    **E. Add frame rendering on top of node sprites:**

    After drawing the node icon sprite, draw the frame sprite on top:
    - Keystones: Look up "KeystoneFrameAllocated" or "KeystoneFrameUnallocated" in the `frame` sprite sheet
    - Notables: Look up "NotableFrameAllocated" or "NotableFrameUnallocated"
    - Normal: Look up "PSSkillFrame" or "PSSkillFrameActive"
    - JewelSocket: Already has frames in the jewel sprite sheet

    Frame destination rect should be centered on the same node position but slightly larger than the icon (frames are decorative borders). Use the frame coord's W/H for sizing.

    **F. Add group background rendering:**

    Add a new `DrawGroupBackgrounds()` method called in `RenderTree()` BEFORE `DrawConnections()`:

    1. Get the `groupBackground` sprite sheet for current zoom level.
    2. For each group in `_treeData.Groups.Values`:
       - Skip if `group.Background == null`
       - Look up `group.Background.Image` (e.g. "PSGroupBackground3") in the groupBackground coords
       - If found, calculate source rect from coords
       - Calculate destination rect: centered on group position (group.X + offsetX, group.Y + offsetY -- IMPORTANT: groups need the same +14000/+11000 offset applied). The offset is already applied to nodes but NOT to groups in SkillTreeData. Either:
         a) Apply offset to group positions in TreeViewerWindow.LoadTreeAsync() (preferred, consistent with node offset)
         b) Or apply offset in the draw operation
       - If `isHalfImage` is true, the sprite represents half the background. Draw it, then draw a horizontally mirrored copy. Use `canvas.Save()`, `canvas.Scale(-1, 1)` for mirroring, then `canvas.Restore()`.
       - Draw with `canvas.DrawBitmap(bgSheet, srcRect, destRect)`

    IMPORTANT: Group X/Y coordinates in the JSON are raw GGG coords (e.g. -11294.2). The tree viewer applies +14000/+11000 offset to node positions in `TreeViewerWindow.LoadTreeAsync()`. Groups need the SAME offset. Add offset application to groups in LoadTreeAsync alongside the existing node offset loop.

    **G. Update RenderTree() call order:**

    ```csharp
    private void RenderTree(SKCanvas canvas)
    {
        DrawGroupBackgrounds(canvas);  // NEW: behind everything
        DrawConnections(canvas);       // Existing
        DrawNodes(canvas);             // Modified: sprites instead of circles
    }
    ```

    **H. Handle async sprite loading in the canvas:**

    The SkillTreeCanvas.Render() method is synchronous (UI thread). Sprite loading is async. Strategy:
    - In Render(), check what sprites are currently available from the service (they're cached in memory after preload)
    - Build the sprite bitmap dictionary synchronously from the service's in-memory cache
    - If sprites aren't loaded yet, fall back to colored circles
    - When sprites finish loading (via preload in TreeViewerWindow), call `InvalidateVisual()` to trigger re-render with sprites

    Add a callback mechanism or use a flag:
    - After `PreloadSpriteSheetsAsync` completes in TreeViewerWindow, call `TreeCanvas.InvalidateVisual()` to re-render with loaded sprites.

    **I. Hit test radius update:**

    Update `FindNodeAtPosition()` to use sprite dimensions instead of hardcoded radii. The sprite coord's W/H determine the visual size. Use `Math.Max(coord.W, coord.H) / 2f` as the hit test radius. If no sprite data available, fall back to existing radii (18f/12f/10f/6f).
  </action>
  <verify>
    `dotnet build src/PathPilot.Desktop/PathPilot.Desktop.csproj` compiles.
    Run the app, import a PoB build, open tree viewer:
    1. Console shows sprite sheet download/loading progress
    2. Nodes render as real PoE sprites (not colored dots)
    3. Allocated nodes show active (brighter) sprites, unallocated show inactive (darker) sprites
    4. Group backgrounds visible behind node clusters (subtle decorative images)
    5. Zooming in/out switches sprite quality (watch console for LOD changes)
    6. Pan, zoom, hover tooltips still work correctly
    7. No memory leak visible (app memory stays stable during zoom in/out cycles)
  </verify>
  <done>
    Nodes render with real PoE sprites. Active/inactive distinction visible. Group backgrounds render behind clusters. LOD switches on zoom. Colored circle fallback works when sprites unavailable. All existing interaction (pan, zoom, hover) works.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of sprite rendering</name>
  <what-built>
    Complete sprite-based skill tree rendering replacing colored dots with authentic PoE node sprites, group background images, and zoom-based quality switching.
  </what-built>
  <how-to-verify>
    1. Run `dotnet run --project src/PathPilot.Desktop/PathPilot.Desktop.csproj`
    2. Import a PoB build (paste code or pobb.in URL) and click "View Tree"
    3. Verify these visual elements:
       a. Normal nodes show small circular icons (not colored dots)
       b. Notable nodes show medium diamond-shaped icons
       c. Keystone nodes show large star/special icons
       d. Allocated nodes appear brighter/active, unallocated appear darker/faded
       e. Group backgrounds visible as subtle circular/oval shapes behind node clusters
    4. Zoom in to maximum -- sprites should be sharp at high zoom
    5. Zoom out to minimum -- sprites should switch to lower quality (smaller, still readable)
    6. Pan around the tree -- rendering stays smooth
    7. Hover over a node -- tooltip still appears with name and stats
    8. Check console output: no error messages, sprite loading counts look correct
  </how-to-verify>
  <resume-signal>Type "approved" or describe visual issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds
2. App launches without errors
3. Tree viewer shows sprites instead of dots
4. Active/inactive distinction is visually clear
5. Group backgrounds render in correct positions
6. Zoom LOD switching works across all 4 thresholds
7. Fallback to colored circles when sprites unavailable
8. No memory leaks during extended use
9. Performance: smooth 60fps rendering maintained
</verification>

<success_criteria>
- VIS-01: Real PoE sprites visible for Normal, Notable, Keystone, Jewel Socket nodes
- VIS-02: Group background images render behind node clusters
- VIS-03: Sprite quality changes automatically based on zoom level
- VIS-04: Allocated nodes use active sprites, unallocated use inactive sprites
- VIS-05: Sprite sheets cached locally in ~/.config/PathPilot/tree-sprites/
- Graceful fallback to colored circles when sprites fail to load
- All existing functionality (pan, zoom, hover, tooltips) unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-sprite-foundation/05-02-SUMMARY.md`
</output>
