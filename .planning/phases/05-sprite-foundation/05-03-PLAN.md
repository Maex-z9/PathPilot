---
phase: 05-sprite-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
  - src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "Zoom and pan perform smoothly without visible lag"
    - "Sprites appear immediately from cache on second launch (no black flash)"
  artifacts:
    - path: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      provides: "Tile-cached rendering for smooth pan/zoom"
      contains: "SKBitmap"
    - path: "src/PathPilot.Desktop/TreeViewerWindow.axaml.cs"
      provides: "Synchronous sprite preloading before canvas display"
      contains: "PreloadSpriteSheetsAsync"
  key_links:
    - from: "src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs"
      to: "Tile cache bitmaps"
      via: "Pre-rendered world-space tiles blitted during pan, invalidated on zoom/allocation change"
      pattern: "_tileCache"
---

<objective>
Fix rendering performance (lag during zoom/pan) and eliminate the 0.5s black flash on cached sprite loading.

Purpose: The current direct-rendering approach (which replaced the OOM-leaking SKPicture) re-draws all visible nodes, connections, and backgrounds every frame. This causes visible lag especially during pan/zoom. Additionally, sprites load asynchronously from disk cache causing a brief black screen. Both issues degrade user experience.

Output: Smooth 60fps pan/zoom via tile-based render caching, and instant sprite display on subsequent launches.
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-sprite-foundation/05-01-SUMMARY.md
@.planning/phases/05-sprite-foundation/05-UAT.md
@src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
@src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
@src/PathPilot.Core/Services/SkillTreeSpriteService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tile-based render cache for smooth pan/zoom and synchronous sprite preloading</name>
  <files>
    src/PathPilot.Desktop/Controls/SkillTreeCanvas.cs
    src/PathPilot.Desktop/TreeViewerWindow.axaml.cs
    src/PathPilot.Core/Services/SkillTreeSpriteService.cs
  </files>
  <action>
    **CRITICAL CONTEXT**: The OOM crash was caused by SKPicture's DrawPicture() leaking GPU textures when replaying recorded DrawBitmap operations (~150MB per frame). SKPicture was removed entirely. The current approach renders all visible nodes/connections/backgrounds directly every frame, which works but is slow. We need a caching mechanism that does NOT use SKPicture.

    **Strategy: Off-screen SKBitmap tile cache**

    The key insight is: during PAN, the world content doesn't change -- only the viewport offset moves. We can pre-render the visible world region to an off-screen SKBitmap, then blit (copy) that bitmap to screen each frame. Only re-render when zoom changes, allocation changes, or the viewport moves outside the cached region.

    **A. Add tile cache fields to SkillTreeCanvas (outside the draw operation):**

    ```csharp
    // Tile cache: a single off-screen bitmap covering a region larger than the viewport
    private SKBitmap? _tileCacheBitmap;
    private SKRect _tileCacheWorldRect;  // World-space rect the cache covers
    private float _tileCacheZoom;         // Zoom level when cache was created
    private string? _tileCacheZoomKey;    // Sprite zoom key when cache was created
    private int _tileCacheAllocVersion;   // Allocation version counter
    private int _allocVersion = 0;        // Incremented when allocated nodes change
    ```

    **B. Cache sizing and invalidation logic:**

    The cache bitmap should cover ~2x the viewport in each direction (so panning doesn't immediately invalidate). For example, if viewport is 1000x800 pixels, cache covers 2000x1600 pixels of world space (at current zoom).

    Cache is INVALID when:
    - Zoom level changed (requires full re-render at new scale)
    - Sprite zoom key changed (new LOD sprites loaded)
    - Allocation changed (allocated/unallocated colors change)
    - Viewport has panned more than 25% outside the cached region

    **C. Implement InvalidateTileCache() method:**

    Call this when:
    - ZoomLevel property changes (already triggers AffectsRender)
    - AllocatedNodeIds property changes -> increment `_allocVersion`
    - Sprite cache rebuilds (zoom key change / new sprites loaded)
    - HighlightedNodeIds changes

    ```csharp
    private void InvalidateTileCache()
    {
        _tileCacheBitmap?.Dispose();
        _tileCacheBitmap = null;
    }
    ```

    Override `OnPropertyChanged` to detect AllocatedNodeIds changes and increment _allocVersion + invalidate cache.

    **D. Modify SkillTreeDrawOperation.Render() to use tile cache:**

    The draw operation receives a reference to the tile cache state from the owning SkillTreeCanvas (pass via constructor -- the draw operation already receives `_owner`).

    In `Render()`:
    1. Calculate the current viewport world rect (already done as `_visibleRect`)
    2. Check if `_owner._tileCacheBitmap` is valid:
       - Exists AND _tileCacheZoom matches current zoom AND _tileCacheAllocVersion matches AND _tileCacheZoomKey matches AND viewport is within cached region
    3. If valid: just blit the cached bitmap to screen using `canvas.DrawBitmap()` with appropriate source/dest rects (offset by how much the viewport has moved within the cache). Then draw highlights on top (highlights change frequently with hover).
    4. If invalid: render the full scene to a new off-screen SKBitmap:
       a. Calculate cache region: expand viewport by 50% in each direction (covers 2x area)
       b. Create SKBitmap of appropriate pixel size: `(cacheWorldWidth * zoom, cacheWorldHeight * zoom)`
       c. Create SKCanvas from the bitmap
       d. Apply transform so world coords map to bitmap coords
       e. Call DrawGroupBackgrounds, DrawConnections, DrawNodes on the cache canvas
       f. Store the bitmap in `_owner._tileCacheBitmap`, update `_tileCacheWorldRect`, `_tileCacheZoom`, etc.
       g. Blit the relevant portion to screen
       h. Draw highlights on top of the screen canvas (not cached)

    **IMPORTANT memory safety:**
    - Limit cache bitmap size to a maximum of 4096x4096 pixels (prevent OOM at high zoom)
    - If calculated cache size exceeds limit, reduce the cache margin (cover less area, more frequent rebuilds but safe memory)
    - Dispose old cache bitmap before creating new one
    - Use `SKImageInfo` with `SKColorType.Rgba8888` for consistent format

    **E. Optimize pan to use cache without re-render:**

    In `OnPointerMoved` during panning, the offset changes but NO tile cache invalidation should happen (that's the whole point). The draw operation will detect that the viewport is still within the cached region and blit the cached bitmap with the new offset.

    Only invalidate when the viewport edge gets close to the cache edge (within 25% of cache extent).

    **F. Fix sprite preloading to eliminate black flash (TreeViewerWindow.axaml.cs):**

    The 0.5s black screen happens because `PreloadSpriteSheetsAsync` loads sprites from disk asynchronously, and the canvas renders before they're ready. Fix:

    1. In `LoadTreeAsync()`, move sprite preloading BEFORE setting TreeData on the canvas. Currently the order is:
       ```
       PreloadSpriteSheetsAsync  -> SetTreeData on canvas -> CenterOnAllocatedNodes
       ```
       This is already correct in the current code, but the canvas might render before preload completes due to UI thread scheduling. Ensure the `await PreloadSpriteSheetsAsync()` truly completes before `TreeCanvas.TreeData = treeData` is set.

    2. Also add synchronous bitmap availability check: after `PreloadSpriteSheetsAsync` returns, verify that `_spriteService.TryGetLoadedBitmap()` returns non-null for at least the key sprite sheets. If not, the preload may have failed silently.

    3. In SkillTreeSpriteService, optimize disk cache loading: `SKBitmap.Decode(stream)` can be slow for large JPEGs. Consider loading on a background thread and using `ConfigureAwait(false)` consistently.

    **G. Optimize direct rendering path (micro-optimizations in DrawNodes/DrawConnections):**

    Even with tile caching, the cache rebuild needs to be fast. Apply these optimizations:

    1. **SKPaint pooling**: Move `using var allocatedPaint = new SKPaint{...}` declarations to static or cached fields. Creating and disposing SKPaint objects per frame is wasteful. Create them once as static readonly or as fields on the draw operation, and reuse.

    2. **DrawConnections**: The `HashSet<long> drawnConnections` allocates each frame. Pre-allocate with expected capacity: `new HashSet<long>(treeData.Nodes.Count * 2)`.

    3. **Batch sprite draws**: Group nodes by sprite type to minimize texture switching. Instead of iterating all nodes and switching sprite sheet per node, iterate by sprite type.

    4. **SKPaint for bitmaps**: Create ONE SKPaint for all bitmap draws with `FilterQuality = SKFilterQuality.Low` (faster than Medium, acceptable for game sprites). Use `Medium` only when zoomed in close (zoom > 0.3).

  </action>
  <verify>
    `dotnet build src/PathPilot.Desktop/PathPilot.Desktop.csproj` compiles without errors.
    Run the app, open tree viewer:
    1. Panning should feel smooth (no visible lag or stutter)
    2. Zooming should be responsive (slight pause acceptable during cache rebuild, but not laggy)
    3. On second launch, sprites appear immediately (no 0.5s black flash)
    4. Memory usage stays stable (no growth during extended pan/zoom -- check via task manager)
    5. Console should NOT show "SKPicture" anywhere (confirm it's not reintroduced)
  </verify>
  <done>
    Pan is smooth without lag. Zoom is responsive with at most a brief pause during LOD transitions. Sprites appear immediately from disk cache on second launch. Memory stays stable during extended use.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Performance verification</name>
  <files></files>
  <action>
    User verifies that tile-based render caching delivers smooth pan/zoom, and sprite preloading eliminates the black flash on cached launches.
  </action>
  <verify>
    1. Run `dotnet run --project src/PathPilot.Desktop/PathPilot.Desktop.csproj`
    2. Import a build and open the Skill Tree viewer
    3. Test PANNING: Click and drag to pan around the tree. Should feel smooth without lag or stuttering.
    4. Test ZOOMING: Use mouse wheel or touchpad to zoom in/out. Should be responsive. A brief pause during LOD threshold crossing is acceptable.
    5. Test SECOND LAUNCH: Close the tree viewer window, then reopen it. Sprites should appear immediately without a black flash.
    6. Test EXTENDED USE: Pan and zoom around for 30+ seconds. No increasing lag or memory growth.
    7. Compare to previous behavior: is the lag noticeably reduced/eliminated?
  </verify>
  <done>
    User confirms: pan and zoom are smooth without lag, sprites appear immediately from cache, no memory issues during extended use.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds without errors
2. Pan interaction is smooth (no visible frame drops)
3. Zoom interaction is responsive
4. No black flash on second launch
5. Memory stays stable during extended pan/zoom
6. No OOM crash (the fix that caused this gap is preserved)
7. All existing functionality (hover, tooltips, LOD, search) still works
</verification>

<success_criteria>
- Gap 6 (major): Zoom and pan perform smoothly without lag -- CLOSED
- Gap 5 (minor): Sprites appear immediately from cache on second launch -- CLOSED
- No regression: OOM crash does not return (no SKPicture reintroduction)
- All existing Phase 5 functionality preserved (sprites, LOD, active/inactive, group backgrounds)
</success_criteria>

<output>
After completion, create `.planning/phases/05-sprite-foundation/05-03-SUMMARY.md`
</output>
